# План рефакторинга: каноническая семантическая адресация (domain|doc|chunk|idx|flags)

## Намерение

Превратить каждый sentence‑vector в системе в **устойчивый семантический адрес**: один `int`, который переживает load/unload, ре‑гидратацию FAISS, пересборку кешей и будущее версионирование. Система начинает работать как резонатор: волна входит один раз, а интерференционная картина всегда воспроизводима по тем же координатам.

---

## Текущие проблемы → Почему они мешают (аналогии: волна / резонатор)

### Проблема 1: Идентичность «плывёт» при reload
**Симптом:** После пересборки FAISS или rehydration вектор может получить другой идентификатор, если заново строится таблица соответствий.  
**Почему это плохо:** Риджи и семантические маски — это «тонкие прожилки» в heatmap. Если система координат смещается, тот же ридж нельзя воспроизвести. Интерференция меняется не потому, что волна другая, а потому что сдвинулись оси.

**Решение:** Сделать идентичность детерминированной:  
`int_id = encode(domain, doc_id, chunk_id, idx_in_doc, flags)`  
ID создаётся при ingestion и больше не меняется.

---

### Проблема 2: Packed‑id не содержит `domain` и `idx_in_doc`
**Симптом:** `doc_id__chunk_id` недостаточно описателен и не кодирует «время вдоль документа» (`idx_in_doc`).  
**Почему это плохо:** Exciter и Condensation — это операции вдоль документной волны. Без `idx_in_doc` ты вынужден «искать соседей» логикой, а не арифметикой. Физика превращается в бухгалтерию.

**Решение:** Добавить `idx_in_doc` и `flags` в канонический `int_id`.  
Если `idx_in_doc` — младшие биты, локальные окна становятся непрерывными диапазонами.

---

### Проблема 3: Несколько реализаций cosine similarity
**Симптом:** Semantic может считать similarity, FAISS — считает, плюс есть варианты с вращением / фазой.  
**Почему это плохо:** Две реализации cosine — это две разные маски. Одна и та же волна даёт разную интерференцию. Микро‑различия чисел → другие границы риджей → другой sampling.

**Решение:** Один канонический закон similarity.  
Semantic **никогда** не считает cosine сам.  
Similarity живёт в `yo` (ё) и используется везде.

---

### Проблема 4: Таблица `rag_document` дублирует сущности
**Симптом:** `rag_document` хранит `domain`, `key`, `temporary`, `mtime` на уровне документа.  
**Почему это плохо:** Документный `mtime` — грубые часы. А система работает на уровне волны предложений. Время принадлежит чанку / предложению, а не контейнеру.

**Решение:**  
- `temporary` → 1 бит в `flags`  
- `mtime` → на уровень chunk / sentence  
- `rag_document` убрать или понизить до необязательного human‑metadata

---

## Целевая архитектура (после рефакторинга)

### Канонический ключ

Один `int_id` — координата семантического атома:

- `domain`        — в каком резонаторе
- `doc_id`        — источник волны
- `chunk_id`      — логический блок
- `idx_in_doc`    — позиция во времени документа
- `flags`         — биты жизненного цикла и будущих режимов

**Свойство:** одно и то же предложение всегда имеет один и тот же `int_id`.

---

### Роли (чистое разделение)

#### Semantic
Чистый преобразователь: `text → sentences → vectors`, плюс оркестрация Exciter / Condensation.  
Хранит `id ↔ text` в памяти и использует каноническую similarity.

#### FAISS
Ускоритель. Хранит векторы и возвращает `id`. Истину не определяет.

#### SQLite
Хранилище фактов. Хранит `id`, текст предложения и `mtime` для будущего версионирования.

#### `yo` (ё)
Физика волн: similarity, Exciter, Condensation, интерференция.  
WordWield — оркестр, `yo` — законы природы.

---

## Изменения модели данных (SQLite)

### Таблица семантических атомов

Минимальный набор для воспроизведения волны:

- `id`    : INTEGER PRIMARY KEY (`int_id`)
- `text`  : TEXT
- `mtime` : INTEGER
- `meta`  : опционально

**Идея:** `id` — идеальный хеш. Lookup O(1).

---

## Раскладка битов (encode layout)

### Принципы
- Неизменяемость (ABI системы)
- Диапазоны по `idx_in_doc`
- Флаги без разрушения непрерывности

### Ключевая идея
`idx_in_doc` — **младшие биты**  
→ окна возбуждения = `[id - r, id + r]`  
→ Condensation — линейный проход по волне

Флаги — выше `idx_in_doc`.

---

## Оптимизации, которые открывает `idx_in_doc`

### 1) Exciter = генератор диапазона
Без поиска соседей:
```
excite(center_id, r) → [center_id - r, center_id + r]
```

Чистая арифметика.

---

### 2) Condensation = скан волны
Carrier, инерция, затухание — один проход по возрастающим `id`.  
Replay и rewind детерминированы.

---

### 3) Bulk‑доступ и cache‑friendly память
Непрерывные `id`:
- batch FAISS fetch
- предзагрузка окон
- меньше random access

Это уже «распространение волны», а не «охота за векторами».

---

### 4) Персистентные риджи
Ридж = список `int_id`.  
Сегодня найден → завтра воспроизведён без пересчёта.

---

## План рефакторинга (по фазам)

### Фаза 0: Зафиксировать закон (ABI)
**Проблема:** смена encode ломает всё.  
**Решение:** версия encode — закон системы.

---

### Фаза 1: ID создаётся при ingestion
В RAG‑service:
1. определить `doc_id`
2. sentencize
3. назначить `idx_in_doc`
4. вычислить `int_id`
5. сохранить `id ↔ text`, `mtime`
6. положить вектор в FAISS с тем же `id`

---

### Фаза 2: Semantic = чистая семантика
- не считает cosine
- не хранит векторы как истину
- делегирует физику в `yo`

---

### Фаза 3: Одна similarity на всё
- `yo.cossim` — канон
- FAISS согласован по нормализации
- никаких дубликатов

---

### Фаза 4: Убрать `rag_document`
- identity и lifecycle в `int_id`
- время — на уровне предложения
- документ = диапазон `id`

---

## Миграция

1. Добавить новую схему рядом со старой  
2. Перекодировать существующие данные  
3. Сравнить риджи (old vs new)  
4. Переключиться  
5. Удалить старое

---

## Риски и защита

- **Сдвиг координат** → encode = закон  
- **Вставка предложений** → новая версия волны  
- **Флаги в младших битах** → разрушение диапазонов

---

## Резюме

Ты превращаешь систему в устойчивый резонатор:  
волна входит → координаты фиксируются → интерференция воспроизводима.  

Один адрес.  
Один закон similarity.  
Одна физика в `yo`.
